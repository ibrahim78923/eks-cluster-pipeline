name: Build, Push, Deploy to Kubernetes

on:
  push:
    branches:
      - prod

jobs:
  build-push-deploy:
    runs-on: ubuntu-latest
    env:
      AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
      KUBECTL_CLUSTER_NAME: ${{ secrets.KUBECTL_CLUSTER_NAME }}
      KUBECTL_NAMESPACE: ${{ secrets.KUBECTL_NAMESPACE }}
    steps:
      - uses: actions/checkout@v3

      - name: Configure AWS credentials
        run: aws configure set aws_access_key_id ${{ env.AWS_ACCESS_KEY_ID }} && aws configure set aws_secret_access_key ${{ env.AWS_SECRET_ACCESS_KEY }}

      - name: Login to ECR
        uses: aws-actions/ecr-login@v3

      - name: Build Docker image
        run: docker build -t $ECR_REPOSITORY:$GITHUB_SHA .

      - name: Tag and push Docker image to ECR
        run: |
          docker tag $ECR_REPOSITORY:$GITHUB_SHA $ECR_REPOSITORY:latest
          docker push $ECR_REPOSITORY:$GITHUB_SHA
          docker push $ECR_REPOSITORY:latest

#       - name: Configure kubectl context
#         uses: eks-platform/eks-kubectl@v3
#         with:
#           cluster-name: ${{ env.KUBECTL_CLUSTER_NAME }}
#           region: ${{ env.AWS_DEFAULT_REGION }}

#       - name: Apply Kubernetes manifests
#         run: |
#           kubectl apply -f deployments.yaml -n ${{ env.KUBECTL_NAMESPACE }}
#           # Add additional manifest application steps as needed

#       - name: (Optional) Verify deployment status
#         # Add custom steps to verify successful deployment, e.g., using kubectl get pods

# **Important notes:**

# * You need to create GitHub Secrets with the following names and values:
#     * `AWS_REGION`: Your AWS region
#     * `AWS_ACCESS_KEY_ID`: Your AWS access key ID
#     * `AWS_SECRET_ACCESS_KEY`: Your AWS secret access key
#     * `ECR_REPOSITORY`: The name of your ECR repository
#     * `KUBECTL_CLUSTER_NAME`: The name of your Kubernetes cluster
#     * `KUBECTL_NAMESPACE`: The namespace where you want to deploy the application
# * This workflow assumes you have a `deployments.yaml` file in the root of your repository containing your Kubernetes deployment manifests. You can adjust this depending on your deployment strategy.
# * The optional step for verifying deployment status is commented out. You can implement custom steps to check if the deployment was successful using `kubectl` commands.

# Make sure to:

# * Replace the placeholder values with your actual credentials and repository names.
# * Adjust the commands in the `Apply Kubernetes manifests` step to match your deployment requirements.
# * Implement checks for deployment success if needed.

# This workflow provides a basic foundation for building, pushing, and deploying a Docker image to Kubernetes. You can adapt and enhance it further based on your specific needs.



